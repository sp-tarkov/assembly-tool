using AsmResolver.DotNet;
using AssemblyLib.AutoMatcher.Filters;
using AssemblyLib.Models;
using AssemblyLib.Remapper;
using AssemblyLib.Shared;
using Serilog;
using SPTarkov.DI.Annotations;

namespace AssemblyLib.AutoMatcher;

[Injectable(InjectionType.Singleton)]
public class AutoMatchController(
    MappingController mappingController,
    AssemblyWriter assemblyWriter,
    DataProvider dataProvider,
    IEnumerable<IAutoMatchFilter> filters,
    TypeCache typeCache
)
{
    private ModuleDefinition? Module { get; set; }
    private List<TypeDefinition>? _candidateTypes;

    private string? _newTypeName;

    public async Task AutoMatch(
        string assemblyPath,
        string oldAssemblyPath,
        string oldTypeName,
        string newTypeName,
        bool isRegen
    )
    {
        var result = assemblyWriter.TryDeObfuscate(dataProvider.LoadModule(assemblyPath), assemblyPath);

        if (isRegen)
        {
            var target = dataProvider.GetRemaps().SingleOrDefault(r => r.NewTypeName == newTypeName);

            if (target is null)
            {
                Log.Error("Could not find new type name {name}", newTypeName);
                return;
            }
        }

        _newTypeName = newTypeName;

        assemblyPath = result.Item1;
        Module = result.Item2;

        var targetTypeDef = FindTargetType(oldTypeName);

        if (targetTypeDef is null)
        {
            Log.Error("Could not target type: {OldTypeName}", oldTypeName);
            return;
        }
        Log.Information("Found target type: {FullName}", targetTypeDef.FullName);

        typeCache.HydrateCache();
        _candidateTypes = typeCache.SelectCache(targetTypeDef);

        Log.Information(
            "Found {CandidateTypesCount} potential candidates: {FullName}",
            _candidateTypes?.Count ?? 0,
            targetTypeDef.FullName
        );

        var remapModel = new RemapModel() { NewTypeName = newTypeName, AutoGenerated = true };

        await StartFilter(targetTypeDef, remapModel, assemblyPath, oldAssemblyPath, isRegen);
    }

    private TypeDefinition? FindTargetType(string oldTypeName)
    {
        return Module!.GetAllTypes().FirstOrDefault(t => t.FullName == oldTypeName);
    }

    private async Task StartFilter(
        TypeDefinition target,
        RemapModel remapModel,
        string assemblyPath,
        string oldAssemblyPath,
        bool isRegen
    )
    {
        Log.Information("Starting Candidates: {Count}", _candidateTypes!.Count);

        // Purpose of this pass is to eliminate any types that have no matching parameters
        foreach (var candidate in _candidateTypes!.ToList())
        {
            foreach (var filter in filters)
            {
                if (!filter.Filter(target, candidate, remapModel.SearchParams))
                {
                    _candidateTypes.Remove(candidate);
                }
            }
        }

        switch (_candidateTypes!.Count)
        {
            case 0:
                Log.Error("No potential candidates remain, could not build a signature.");
                break;
            case 1:
                await RunTest(remapModel, assemblyPath, oldAssemblyPath, isRegen);
                break;
            case > 1:
                Log.Information("Could not isolate type {type}", remapModel.NewTypeName);
                Log.Information("Showing all remaining potential types:");
                foreach (var type in _candidateTypes)
                {
                    Log.Information("\t{FullName}", type.FullName);
                }
                break;
        }

        Log.Information("Generated Model:\n{remapModel}", dataProvider.SerializeRemap(remapModel));
    }

    private async Task RunTest(RemapModel remapModel, string assemblyPath, string oldAssemblyPath, bool isRegen)
    {
        Log.Information("Narrowed candidates down to one. Testing generated model...");

        dataProvider.ClearMappings();
        dataProvider.AddMapping(remapModel);

        await mappingController.Run(assemblyPath, string.Empty, validate: true);

        if (remapModel.Succeeded)
        {
            await ProcessEndQuestions(remapModel, assemblyPath, oldAssemblyPath, isRegen);
        }
    }

    private async Task ProcessEndQuestions(
        RemapModel remapModel,
        string assemblyPath,
        string oldAssemblyPath,
        bool isRegen
    )
    {
        Thread.Sleep(1000);

        Log.Information("Signature generation successful!");
        Log.Information("Add remap to existing list?.. (y/n)");
        var resp = Console.ReadLine()?.ToLower();

        if (string.IsNullOrEmpty(resp))
        {
            return;
        }

        AddNewMappingToList(resp, remapModel, isRegen);

        Log.Information("Would you like to run the remap process?... (y/n)");
        var resp2 = Console.ReadLine()?.ToLower();

        if (string.IsNullOrEmpty(resp2))
        {
            return;
        }

        await RunMappingProcess(resp2, assemblyPath, oldAssemblyPath);
    }

    private void AddNewMappingToList(string response, RemapModel remapModel, bool isRegen)
    {
        if (response != "y" && response != "yes")
        {
            return;
        }

        dataProvider.ClearMappings();
        dataProvider.LoadMappingFile();

        var remaps = dataProvider.GetRemaps();

        // Remove the remap so we can re-add it
        if (isRegen && _newTypeName is not null)
        {
            var remap = remaps.First(r => r.NewTypeName == _newTypeName);
            remaps.Remove(remap);
        }

        if (remaps.Any(m => m.NewTypeName == remapModel.NewTypeName))
        {
            Log.Information(
                "Ambiguous new type names found for {RemapModelNewTypeName}. Please pick a different name.",
                remapModel.NewTypeName
            );
            return;
        }

        remaps.Add(remapModel);
        dataProvider.UpdateMappingFile(false);
    }

    private async Task RunMappingProcess(string response, string assemblyPath, string oldAssemblyPath)
    {
        if (response != "y" && response != "yes")
        {
            return;
        }

        var outPath = Path.GetDirectoryName(assemblyPath);

        if (outPath is null)
        {
            throw new DirectoryNotFoundException($"Could not resolve directory for `{assemblyPath}`");
        }

        await mappingController.Run(assemblyPath, oldAssemblyPath, outPath);
    }
}
