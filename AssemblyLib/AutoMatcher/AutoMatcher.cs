using AsmResolver.DotNet;
using AssemblyLib.AutoMatcher.Filters;
using AssemblyLib.Models;
using AssemblyLib.ReMapper;
using AssemblyLib.Utils;
using Serilog;
using SPTarkov.DI.Annotations;

namespace AssemblyLib.AutoMatcher;

[Injectable(InjectionType.Singleton)]
public class AutoMatcher(
    MappingController mappingController,
    AssemblyUtils assemblyUtils,
    DataProvider dataProvider,
    IEnumerable<IAutoMatchFilter> filters
)
{
    private ModuleDefinition? Module { get; set; }
    private List<TypeDefinition>? _candidateTypes;
    private List<string>? _typesToMatch;

    private string? _newTypeName;

    public async Task AutoMatch(
        string assemblyPath,
        string oldAssemblyPath,
        string oldTypeName,
        string newTypeName,
        bool isRegen
    )
    {
        var result = assemblyUtils.TryDeObfuscate(dataProvider.LoadModule(assemblyPath), assemblyPath);

        _typesToMatch = dataProvider.Settings.TypeNamesToMatch;

        if (isRegen)
        {
            var target = dataProvider.GetRemaps().SingleOrDefault(r => r.NewTypeName == newTypeName);

            if (target is null)
            {
                Log.Error("Could not find new type name {name}", newTypeName);
                return;
            }
        }

        _newTypeName = newTypeName;

        assemblyPath = result.Item1;
        Module = result.Item2;

        var targetTypeDef = FindTargetType(oldTypeName);

        if (targetTypeDef is null)
        {
            Log.Error("Could not target type: {OldTypeName}", oldTypeName);
            return;
        }
        Log.Information("Found target type: {FullName}", targetTypeDef.FullName);

        GetCandidateTypes(targetTypeDef);
        Log.Information(
            "Found {CandidateTypesCount} potential candidates: {FullName}",
            _candidateTypes?.Count ?? 0,
            targetTypeDef.FullName
        );

        var remapModel = new RemapModel() { NewTypeName = newTypeName, AutoGenerated = true };

        await StartFilter(targetTypeDef, remapModel, assemblyPath, oldAssemblyPath, isRegen);
    }

    private TypeDefinition? FindTargetType(string oldTypeName)
    {
        return Module!.GetAllTypes().FirstOrDefault(t => t.FullName == oldTypeName);
    }

    private void GetCandidateTypes(TypeDefinition targetTypeDef)
    {
        if (targetTypeDef.IsNested)
        {
            _candidateTypes = targetTypeDef
                .DeclaringType?.NestedTypes.Where(t => _typesToMatch?.Any(token => t.Name!.StartsWith(token)) ?? false)
                .ToList();

            return;
        }

        _candidateTypes = Module
            ?.GetAllTypes()
            .Where(t => _typesToMatch?.Any(token => t.Name!.StartsWith(token)) ?? false)
            .ToList();
    }

    private async Task StartFilter(
        TypeDefinition target,
        RemapModel remapModel,
        string assemblyPath,
        string oldAssemblyPath,
        bool isRegen
    )
    {
        Log.Information("Starting Candidates: {Count}", _candidateTypes!.Count);

        // Purpose of this pass is to eliminate any types that have no matching parameters
        foreach (var candidate in _candidateTypes!.ToList())
        {
            foreach (var filter in filters)
            {
                if (!filter.Filter(target, candidate, remapModel.SearchParams))
                {
                    _candidateTypes.Remove(candidate);
                }
            }
        }

        if (_candidateTypes!.Count == 1)
        {
            await RunTest(remapModel, assemblyPath, oldAssemblyPath, isRegen);
            return;
        }

        Log.Error("Could not find a match... :(");
    }

    private async Task RunTest(RemapModel remapModel, string assemblyPath, string oldAssemblyPath, bool isRegen)
    {
        Log.Information("Narrowed candidates down to one. Testing generated model...");

        dataProvider.ClearMappings();
        dataProvider.AddMapping(remapModel);

        await mappingController.Run(assemblyPath, string.Empty, validate: true);

        Log.Information("\n{remapModel}", dataProvider.SerializeRemap(remapModel));

        if (remapModel.Succeeded)
        {
            await ProcessEndQuestions(remapModel, assemblyPath, oldAssemblyPath, isRegen);
        }
    }

    private async Task ProcessEndQuestions(
        RemapModel remapModel,
        string assemblyPath,
        string oldAssemblyPath,
        bool isRegen
    )
    {
        Thread.Sleep(1000);

        Log.Information("Add remap to existing list?.. (y/n)");
        var resp = Console.ReadLine()?.ToLower();

        if (string.IsNullOrEmpty(resp))
        {
            return;
        }

        AddNewMappingToList(resp, remapModel, isRegen);

        Log.Information("Would you like to run the remap process?... (y/n)");
        var resp2 = Console.ReadLine()?.ToLower();

        if (string.IsNullOrEmpty(resp2))
        {
            return;
        }

        await RunMappingProcess(resp2, assemblyPath, oldAssemblyPath);
    }

    private void AddNewMappingToList(string response, RemapModel remapModel, bool isRegen)
    {
        if (response != "y" && response != "yes")
        {
            return;
        }

        dataProvider.ClearMappings();
        dataProvider.LoadMappingFile();

        var remaps = dataProvider.GetRemaps();

        // Remove the remap so we can re-add it
        if (isRegen && _newTypeName is not null)
        {
            var remap = remaps.First(r => r.NewTypeName == _newTypeName);
            remaps.Remove(remap);
        }

        if (remaps.Any(m => m.NewTypeName == remapModel.NewTypeName))
        {
            Log.Information(
                "Ambiguous new type names found for {RemapModelNewTypeName}. Please pick a different name.",
                remapModel.NewTypeName
            );
            return;
        }

        remaps.Add(remapModel);
        dataProvider.UpdateMappingFile(false, true);
    }

    private async Task RunMappingProcess(string response, string assemblyPath, string oldAssemblyPath)
    {
        if (response != "y" && response != "yes")
        {
            return;
        }

        var outPath = Path.GetDirectoryName(assemblyPath);

        if (outPath is null)
        {
            throw new DirectoryNotFoundException($"Could not resolve directory for `{assemblyPath}`");
        }

        await mappingController.Run(assemblyPath, oldAssemblyPath, outPath);
    }
}
